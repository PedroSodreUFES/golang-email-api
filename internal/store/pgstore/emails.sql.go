// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: emails.sql

package pgstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmail = `-- name: CreateEmail :one
INSERT INTO emails (
    title, content, id_receiver, id_sender
) VALUES ( $1, $2, $3, $4)
RETURNING id, title, content, wasseen, created_at, id_receiver, id_sender
`

type CreateEmailParams struct {
	Title      string      `json:"title"`
	Content    pgtype.Text `json:"content"`
	IDReceiver int32       `json:"id_receiver"`
	IDSender   int32       `json:"id_sender"`
}

func (q *Queries) CreateEmail(ctx context.Context, arg CreateEmailParams) (Email, error) {
	row := q.db.QueryRow(ctx, createEmail,
		arg.Title,
		arg.Content,
		arg.IDReceiver,
		arg.IDSender,
	)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Wasseen,
		&i.CreatedAt,
		&i.IDReceiver,
		&i.IDSender,
	)
	return i, err
}

const deleteEmail = `-- name: DeleteEmail :execrows
DELETE FROM emails
WHERE id = $1
`

func (q *Queries) DeleteEmail(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteEmail, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getEmailById = `-- name: GetEmailById :one
SELECT id, title, content, wasseen, created_at, id_receiver, id_sender
FROM emails
WHERE id = $1
`

func (q *Queries) GetEmailById(ctx context.Context, id int32) (Email, error) {
	row := q.db.QueryRow(ctx, getEmailById, id)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Wasseen,
		&i.CreatedAt,
		&i.IDReceiver,
		&i.IDSender,
	)
	return i, err
}

const getMyReceivedEmails = `-- name: GetMyReceivedEmails :many
SELECT e.id, title, content, wasseen, created_at, id_receiver, id_sender, u.id, full_name, email, profile_picture
FROM emails e
INNER JOIN users u ON e.id_sender = u.id
WHERE id_receiver = $1
ORDER BY e.id
`

type GetMyReceivedEmailsRow struct {
	ID             int32              `json:"id"`
	Title          string             `json:"title"`
	Content        pgtype.Text        `json:"content"`
	Wasseen        pgtype.Bool        `json:"wasseen"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	IDReceiver     int32              `json:"id_receiver"`
	IDSender       int32              `json:"id_sender"`
	ID_2           int32              `json:"id_2"`
	FullName       string             `json:"full_name"`
	Email          string             `json:"email"`
	ProfilePicture pgtype.Text        `json:"profile_picture"`
}

func (q *Queries) GetMyReceivedEmails(ctx context.Context, idReceiver int32) ([]GetMyReceivedEmailsRow, error) {
	rows, err := q.db.Query(ctx, getMyReceivedEmails, idReceiver)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMyReceivedEmailsRow
	for rows.Next() {
		var i GetMyReceivedEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Wasseen,
			&i.CreatedAt,
			&i.IDReceiver,
			&i.IDSender,
			&i.ID_2,
			&i.FullName,
			&i.Email,
			&i.ProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMySentEmails = `-- name: GetMySentEmails :many
SELECT e.id, title, content, wasseen, created_at, id_receiver, id_sender, u.id, full_name, email, profile_picture
FROM emails e
INNER JOIN users u ON e.id_receiver = u.id
WHERE id_sender = $1
ORDER BY e.id
`

type GetMySentEmailsRow struct {
	ID             int32              `json:"id"`
	Title          string             `json:"title"`
	Content        pgtype.Text        `json:"content"`
	Wasseen        pgtype.Bool        `json:"wasseen"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	IDReceiver     int32              `json:"id_receiver"`
	IDSender       int32              `json:"id_sender"`
	ID_2           int32              `json:"id_2"`
	FullName       string             `json:"full_name"`
	Email          string             `json:"email"`
	ProfilePicture pgtype.Text        `json:"profile_picture"`
}

func (q *Queries) GetMySentEmails(ctx context.Context, idSender int32) ([]GetMySentEmailsRow, error) {
	rows, err := q.db.Query(ctx, getMySentEmails, idSender)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMySentEmailsRow
	for rows.Next() {
		var i GetMySentEmailsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Content,
			&i.Wasseen,
			&i.CreatedAt,
			&i.IDReceiver,
			&i.IDSender,
			&i.ID_2,
			&i.FullName,
			&i.Email,
			&i.ProfilePicture,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAndGetEmailByID = `-- name: UpdateAndGetEmailByID :one
UPDATE emails
SET wasSeen = TRUE
WHERE id = $1
RETURNING id, title, content, wasseen, created_at, id_receiver, id_sender
`

func (q *Queries) UpdateAndGetEmailByID(ctx context.Context, id int32) (Email, error) {
	row := q.db.QueryRow(ctx, updateAndGetEmailByID, id)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Content,
		&i.Wasseen,
		&i.CreatedAt,
		&i.IDReceiver,
		&i.IDSender,
	)
	return i, err
}
